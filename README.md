# go

|제목|내용|
|------|---|
|환경설정|https://learn.microsoft.com/ko-kr/azure/developer/go/configure-visual-studio-code|
|RUN|Ctrl+Alt+N|
|||
|||
|||



# 서식지정자
|구분|설명|
|------|---|
|%v|데이터 타입에 맞춰서 기본 형태로 출력합니다.|
|%T|데이터 타입 출력합니다.|
|%t|불리언을 true/false로 출력합니다.|
|%d|10진수 정숫값으로 출력합니다(정수 타입만 가능).|
|%b|2진수로 출력합니다.|
|%c|유니코드 문자를 출력합니다(정수 타입만 가능).|
|%o|8진수로 출력합니다.|
|%O|앞에 8진수임을 표시하는 0o를 붙여서 8진수로 값을 출력합니다.|
|%x|16진수로 값을 출력합니다. 10 이상 값을 a-f 소문자로 표시합니다.|
|%X|16진수로 값을 출력합니다. 10 이상 값을 A-F 대문자로 표시합니다.|
|%e %E|지수 형태로 실숫값을 출력합니다(실수 타입만 가능).예 : -1.234456e+78|
|%f %F|지수 형태가 아닌 실숫값 그대로 출력합니다(실수 타입만 가능).예 : 123.456|
|%g %G|값이 큰 실숫값은 지수 형태(%e)로 출력하고, 작은 실숫값은 실숫값 그대로(%f) 출력합니다.|
|%s|문자열을 출력합니다.|118 1단계 가볍게 Go 입문하기|
|%q|특수 문자 기능을 동작하지 않고 문자열 그대로 출력합니다. fmt.Printf("%q", "hello\tWorld\n")|위와 같이 하면 \t 와 \n 특수 문자가 동작하지 않고 hello\tworld\n이 출력됩니다.|
|%p|메모리 주소값을 출력합니다.|

# 표준 입력
|함수명|설명|
|---|---|
|Scan()|표준 입력에서 값을 입력받습니다.|
|Scanf()|표준 입력에서 서식 형태로 값을 입력받습니다.|
|Scanln()|표준 입력에서 한 줄을 읽어서 값을 입력받습니다.|
|||
|||
|||
|||
|||


# 자료형
|타입|최솟값|최댓값|소수부|
|----|-----|-----|-----|
|float32|1.175494351e-38|3.402823466e38|7자리|
|float64|2.2250738585072014e-308|1.7976931348623158e308|15자리|


# 요약
- fmt 패키지를 이용해서 데이터를 표준 입출력을 할 수 있습니다.
- 표준 출력 함수로는 Print(), Printf(), Println()이 있습니다.
- 서식 문자를 이용하면 다양한 형식으로 출력할 수 있습니다. 최소 출력 너비와 소숫점 이하 숫자 개수를 지정할 수 있습니다.
- 서식 문자 %v를 사용하면 모든 타입의 기본 서식으로 출력합니다.
- 표준 입력 함수로는 Scan(), Scanf(), Scanln()이 있습니다.
- 입력받을 때 에러가 발생하면 표준 입력 스트림을 지웁시다
- 실수 타입은 서로 값이 같은지 비교하는 == 연산자가 비정상 동작할 수 있습니다.
- Go 언어에서 모든 연산자의 각 항의 타입은 항상 같아야 합니다. 대입 연산자도 마찬가지입니다.
- :=(선언대입문) : var 키워드와 타입생략
- Go 내부에서는 필드 각각이 아닌 구조체 전체를 한 번에 복사합니다. <br>대입 연산자가 우변 값을 좌변 메모리 공간에 복사할 때 ‘복사되는 크기’는 ‘타입 크기’와 같습니다.<br>구조체 크기는 모든 필드를 포함하므로 구조체 전체 필드가 복사되는 겁니다.
- int 크기는 8바이트이고 int32는 4바이트입니다
- unsafe.Sizeof() 함수는 해당 변수의 메모리 공간 크기를 반환
- 메모리 정렬이란 컴퓨터가 데이터에 효과적으로 접근하고자 메모리를 일정 크기 간격으로 정렬하는 것을 말합니다
- 불필요한 메모리 낭비를 줄이려면 작은 크기 필드값을 앞에 배치합시다.
- 메모리 주솟값은 %p로 출력
- 포인터 변숫값을 초기화하지 않으면 기본값은 nil.<br>이 값은 0이지만 정확한 의미는 유효하지 않는 메모리 주솟값 즉 어떤 메모리 공간도 가리키고 있지 않음을 나타냅니다.
- 64비트 컴퓨터에서 메모리 주소는 8바이트이고 32비트 컴퓨터에서는 4바이트 크기를 갖습니다
- 인스턴스란 메모리에 할당된(존재하는) 데이터의 실체를 말합니다.
- Go 언어는 어떤 타입이나 메모리 할당 함수에 의해서 스택 메모리를 사용할지 힙 메모리를 사용할지를 결정하는 게 아닙니다.<br> 메모리 공간이 함수 외부로 공개되는지 여부를 자동으로 검사해서 스택 메모리에 할당할지 힙 메모리에 할당할지 결정합니다.
- 또 Go 언어에서 스택 메모리는 계속 증가되는 동적 메모리 풀입니다.<br> 일정한 크기를 갖는 C/C++ 언어와 비교해 메모리 효율성이 높고, 재귀 호출 때문에 스택 메모리가 고갈되는 문제도 발생하지 않습니다.
- UTF-8은 한 글자가 1~3바이트 크기이기 때문에 UTF-8 문자값을 가지려면 3바이트가 필요합니다.<br>하지만 Go 언어 기본 타입에서 3바이트 정수 타입은 제공되지 않기 때문에 rune 타입은 4바이트 정수 타입인 int32 타입의 별칭 타입입니다.<br>type rune int32 // rune 타입과 int32는 이름만 다를 뿐 같은 타입입니다.
- 


> 메모리정렬<br>
레지스터는 실제 연산에 사용되는 데이터가 저장되는 곳.<br>
레지스터 크기가 4바이트인 컴퓨터를 32비트 컴퓨터라 부르고<br>
레지스터 크기가 8바이트인 컴퓨터를 64비트 컴퓨터라고 함.<br>
레지스터 크기가 8바이트라는 얘기는 한 번 연산에 8바이트 크기를 연산할 수 있다는 얘기<br>
64비트 컴퓨터에서 int64 데이터의 시작 주소가 100번지일 경우 <br>
100은 8의 배수가 아니기 때문에 레지스터 크기 8에 맞게 정렬되어 있지 않습니다.<br>
이럴 경우 데이터를 메모리에서 읽어올 때 성능을 손해보기 때문에<br>
처음부터 프로그램 언어에서 데이터를 만들 때 8의 배수인 메모리 주소에<br>
데이터를 할당합니다. 이 경우 100번지가 아니라 8의 배수인 104번지에 할당<br>
메모리 정렬을 위해서 필드 사이에 공간을 띄우는 것을 메모리 패딩Memory Padding이라고 합니다<br>
참고로 4바이트 변수의 시작 주소는 4의 배수로 맞추고 2바이트 변수의 시작 주소는 2의
배수로 맞춰서 패딩

<br>
<br>

> # 메모
> ## 포인터가 유효한 메모리 주소를 가리키는지 검사하는 구문<br>
> var p *int<br>
> if p != nil {<br>
> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// p가 nil이 아니라는 얘기는 p가 유효한 메모리 주소를 가리킨다는 뜻입니다.<br>
> }<br>
>
> ## 포인터변수 초기화
> p1 := &Data{} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1 &를 사용하는 초기화<br>
> var p2 = new(Data) &nbsp;&nbsp;// 2 new()를 사용하는 초기화<br>
> // new() 내장 함수는 인수로 타입을 받습니다. 타입을 메모리에 할당하고 기본값으로 채워 그 주소를 반환.<br>
> // 1 방식은 p1 := &Data{ 3, 4 }처럼 사용자 초기화가 가능<br>
> // 2 방식은 new를 이용해서 내부 필드값을 원하는 값으로 초기화할 수는 없다.

|연산자|설명|
|------|----|
|[ ]|배열의 요소에 접근할 때 사용합니다.|
|.|구조체나 패키지 요소에 접근할 때 사용합니다.|
|&|변수의 메모리 주솟값을 반환합니다.|
|*|포인터 변수가 가리키는 메모리 주소에 접근합니다.|
|...|슬라이스 요소들에 접근하거나 가변 인수를 만들 때 사용합니다.|
|:|배열의 일부분을 집어올 때 사용합니다.|
|<-|채널에서 값을 빼거나 넣을 때 사용합니다.|





